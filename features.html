---
layout: features
title: Features
permalink: /features/
class: features-page
---

<style>
  table {
    width: 100%; /* Ширина таблицы */
  }
  td {
    padding: 5px; /* Поля в ячейках */
    vertical-align: top; /* Выравнивание по верхнему краю ячеек */
  }
</style>

{% include doc-shortcut-tip.html %}


<h2 id="editor" align="center">Smart editor</h2>
<h3>Syntax highlighting</h3>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%">On top of the basic lexer highlighting, Intellij Rust highlights inferred types and macros, including generated modules and methods from <code>impl</code> blocks. It also marks mutable elements in your code:</td>
    <td>Those expressions and functions within <code>unsafe {}</code> blocks that perform unsafe operations are additionally highlighted with contrast background:</td>
  </tr>
  <tr>
    <td><img src="/assets/features/smart_editor/highlight_basic.png" width="400"></td>
    <td><img src="/assets/features/smart_editor/highlight_unsafe.png" width="400"></td>
  </tr>
</table>
<br/>
<p>The highlighting palette is fully customizable for both Darcula and Light color schemes.</p>



  <h3>Quick docs and Quick definition</h3>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%" >At any code element, including library functions, invoke <strong>Quick Doc</strong> (<code>Ctrl+Q / F1</code>) to view the documentation popup. If there is a piece of code in the docs, it will be formatted and highlighted properly:</td>
    <td>To view the implementation or declaration of an element without leaving your current context, call <strong>Quick Definition</strong> by pressing <code>Ctrl+Shift+I / ⌥Space</code>:</td>
  </tr>
  <tr>
    <td><img src="/assets/features/smart_editor/quick_doc.png" width="400"></td>
    <td><img src="/assets/features/smart_editor/quick_def.png" width="450"></td>
  </tr>
</table>
<br/>
<p>Another handy option for viewing documentation is the <img src="/assets/features/smart_editor/docsrs.svg" width="16"> gutter icon, which you can see next to the extern crate declarations. Click it, and you will jump right to the particular crate’s description on <a href="docs.rs">docs.rs</a>.</p>

<!--div class="feature-group">
  <div class="feature half">
<p>At any code element, including library functions, invoke Quick Doc (Ctrl+Q / F1) to view the documentation popup. If there is a piece of code in the docs, it will be formatted and highlighted properly:</p>
    <p>img 3</p>
  </div>
  <div class="feature half">
<p>To view the implementation or declaration of an element without leaving your current context, call Quick Definition by pressing Ctrl+Shift+I / ⌥Space:</p>
    <p>img 4</p>
  </div>
  <p>Another handy option for viewing documentation is the <img src="/assets/features/smart_editor/docsrs.svg" width="16"> gutter icon, which you can see next to extern crate declarations. Click it, and you will jump right to the particular crate’s description on docs.rs.</p>
</div-->


  <h3>Hints and Type information</h3>
<p>Hints for function argument names, types, and lambda parameters are displayed in the editor, and IntelliJ Rust adjusts them as you type. If you prefer not to see some of the hints or hide all of them, you can always tune it in the settings.</p>


<table border="1" cellpadding="5">
  <tr>
    <td width="50%" >If you press <code>Ctrl</code> and hover the mouse over a hint, it will get into an interactive inlay:</td>
    <td>You can also get the type information by calling <strong>Type Info</strong> (<code>Ctrl + Shift + P / ⌃⇧P</code>) for a selected expression:</td>
  </tr>
  <tr>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=450
               src="/assets/features/smart_editor/hints_inlay.png" data-gif="/assets/features/smart_editor/hints_inlay.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=500
             src="/assets/features/smart_editor/type_info.png" data-gif="/assets/features/smart_editor/type_info.gif"/></td>
  </tr>
</table>

<!--
<p>If you press <code>Ctrl</code> and hover the mouse over a hint, it will get into an interactive inlay:
<img class="gif" data-wait="true" data-scope="gif-scope" width=500
     src="/assets/features/smart_editor/hints_change.png" data-gif="/assets/features/smart_editor/hints_change.gif"/>
</p>

<p>You can also get the type information by calling Type Info (<code>Ctrl + Shift + P / ?</code>) for a selected expression:
<img class="gif" data-wait="true" data-scope="gif-scope" width=500
     src="/assets/features/smart_editor/type_info.png" data-gif="/assets/features/smart_editor/type_info.gif"/>
</p>
-->
<br/>
<p>Another alternative to view the types is to turn off the <strong>Show local variable type hints</strong> option and hover your mouse while holding <code>Ctrl / ⌘</code>.</p>



  <h3>Macro expansion popup</h3>
<p>To explore the expansion of any declarative macro in your code, press <code>Alt/⌥ + Enter</code> and choose to view either one-step or full recursive expansion. This feature is a part of the macro expansion functionality that affects most of the code insight.
</p>
<div class="pic">
<img class="gif" data-wait="true" data-scope="gif-scope" width=550
     src="/assets/features/smart_editor/macro_expansion.png" data-gif="/assets/features/smart_editor/macro_expansion.gif"/>
</div>
<p></p>

  <h3>Doc comments highlighting</h3>
<p>Code block inside Doc comments are treated as valid Rust code: you get full code insight including syntax highlighting, completion, and intentions.</p>
<div class="pic">
  <img src="/assets/features/smart_editor/doc_comments_hl.png" width="600">
</div>
<p></p>

  <h3>Code style and formatting</h3>

<p>IntelliJ Rust helps your code stay compliant with style guidelines and naming conventions. You can configure every detail of the preferred style, and adjust the inspections that validate your code against Rust naming conventions.</p>

<p>To explicitly reformat your code, you can use the built-in action (<code>Code | Reformat</code> or <code>Ctrl+Alt+L / ⌥⌘L</code>) or call <a href="https://github.com/rust-lang/rustfmt">rustfmt</a> (<code>Code | Reformat Cargo Project with Rustfmt</code> or using the special button in the Cargo tool window).</p>



  <h2 id="completion" align="center">Code completion</h2>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%">Completion for your Rust code works as you type. It is available for attributes and elements inside <code>#[derive]</code>, including standard library traits:</td>
    <td>For out-of-scope items, like the cases of adding a trait import during method completion, the corresponding <code>use</code> item is inserted automatically:</td>
  </tr>
  <tr>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_completion/completion_derive.png" data-gif="/assets/features/code_completion/completion_derive.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=250
             src="/assets/features/code_completion/completion_trait.png" data-gif="/assets/features/code_completion/completion_trait.gif"/></td>
  </tr>
</table>
<br/>
<p>In addition, IntelliJ Rust provides completion inside macro calls. It knows the resulting macro substitution and suggests the applicable items:</p>

<div class="pic"><img src="/assets/features/code_completion/completion_macro_calls.png" width="400">
</div>
<p></p>


  <h2 id="codegen" align="center">Code generation</h2>

    <h3>Intentions and quick-fixes</h3>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%">The <i>Add missing fields</i> quick fix helps you interactively define field values of struct literals:</td>
    <td>You can quickly add <code>#[derive]</code> clauses and <code>impl</code> blocks for structs and enums, and perform struct-to-tuple and tuple-to-struct conversion:</td>
  </tr>
  <tr>
    <td>
      <img class="gif" data-wait="true" data-scope="gif-scope" width="400"
           src="/assets/features/code_generation/missing_fields.png" data-gif="/assets/features/code_generation/missing_fields.gif"/>
    </td>
    <td><img src="/assets/features/code_generation/add_derive_close.png" width="250"></td>
  </tr>
</table>
<br/>
<p>Auto-import works for all unresolved references in your code:</p>
<div class="pic">
  <img class="gif" data-wait="true" data-scope="gif-scope" width=500
       src="/assets/features/code_generation/auto-import.png" data-gif="/assets/features/code_generation/auto-import.gif"/>
</div>
<p></p>
<p>IntelliJ Rust also checks <code>match</code> expressions in your code and suggest to remove unreachable patterns or add missing ones, including the cases of complex patterns with multiple types. This inspection also supports <a href="https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md">match ergonomics</a>.</p>
<div class="pic">
  <img src="/assets/features/code_generation/mathc_checks.png" width="400">
</div>
<p></p>

    <h3>Live templates, ‘Surround with’, and Postfix completion</h3>
<p>There is a number of ready-to-use live templates to help you insert frequently used Rust constructs into your code. You can always customize and extend this set.
</p>
<p>
  Which templates will be available is defined by the current context: press <code>Ctrl/⌘ + J</code> to see the options. If you already know the abbreviation, just start typing it, choose from the list of suggestions, and then press <code>Tab</code> to navigate between the template variables:
</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=500
        src="/assets/features/code_generation/livetemplates_basic.png" data-gif="/assets/features/code_generation/livetemplates_basic.gif"/>
</div>
<p></p>

<p>You can select a piece of code and press <code>Ctrl+Alt+J / ⌥⌘J</code> to surround it with a live template, or press <code>Ctrl+Alt+T / ⌥⌘T</code> to surround it with <code>loop</code>, <code>while</code>, <code>if</code>, <code>for</code>, or other wrappers, depending on the context.</p>
<p>Another option to insert code constructs is postfix completion. For example, type <code>.dbg</code> after an expression to insert a <code>dbg!</code> invocation for it:</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=600
        src="/assets/features/code_generation/postfix.png" data-gif="/assets/features/code_generation/postfix.gif"/>
</div>
<p></p>


    <h3>Refactorings</h3>
<p>IntelliJ Rust supports the following refactorings:</p>
<ul>
  <li>Rename (Shift+F6 / ⇧F6)</li>
  <li>Extract Variable (Ctrl+Alt+V / ⌥⌘V)</li>
  <li>Extract Parameter (Ctrl+Alt+P / ⌥⌘P)</li>
  <li>Extract Method (Ctrl+Alt+M / ⌥⌘M)</li>
  <li>Convert to Tuple / Struct</li>
  <li>Promote / Downgrade module</li>
</ul>

<p>One of the most frequently used refactorings, <strong>Rename</strong> (<code>Shift+F6 / ⇧F6</code>), renames any symbols and automatically corrects all the references in your code. For example, when you rename a trait item, the corresponding items in the trait implementations are renamed as well:
</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=400
        src="/assets/features/code_generation/rename_trait.png" data-gif="/assets/features/code_generation/rename_trait.gif"/>
</div>
<p></p>
<p>You can rename symbols in-place or use a dialog with a preview.</p>
<p>At any place in your code, call <strong>Rector This</strong> (<code>Ctrl+Shift+Alt+T / ⌃T</code>) to see the list of available context-depend refactorings. As an example, here is how you can easily put the result of an expression into a variable, affecting all usages:
</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=600
        src="/assets/features/code_generation/extract_var.png" data-gif="/assets/features/code_generation/extract_var.gif"/>
</div>
<p></p>


  <h2 id="navigation" align="center">Navigation and search</h2>
<h3>Search everywhere</h3>
<p>The easiest way to find anything in the IDE - a code item, action, or UI element - is Search Everywhere. Press <code>Shift/⇧</code> twice and start typing what you’re looking for. Completion also works in this dialog to help you find the desired item, and you can narrow the search by setting the required scope:</p>
<div class="pic"><img src="/assets/features/navigation/search_everywhere.png" width="600"></div>
<p></p>

<h3>Find Usages</h3>
<p>To locate all the occurrences of any symbol in your code, place the caret on it and call Find Usages. The IDE understands symbol context, so you will not see textual matches in the results.</p>
<p>You can highlight the usages in the current file by pressing <code>Ctrl+Shift+F7 / ⇧⌘F7</code>, and then jump between them, or list all usages in a separate window using <code>Alt+F7 / ⌥F7</code>. In the results window, you can filter and group the results, and jump back to the source code:
</p>
<div class="pic"><img src="/assets/features/navigation/find_usages.png" width="500"></div>
<p></p>


<h3>Go-To and File Structure</h3>
<p>In addition to Search Everywhere, you can separately call Go To class (<code>Ctrl+O / ⌘O</code>), symbol (<code>Ctrl+Alt+O / ⌥⌘O</code>), or file (<code>Ctrl+Shift+O / ⇧⌘O</code>).</p>

<p>To navigate through declarations/definitions and hierarchies in your code, use Go-To action for Declaration (<code>Ctrl+B / ⌘B</code>), Definition (<code>Ctrl+Alt+B / ⌥⌘B</code>), Type Declaration (<code>Ctrl+Shift+B / ⇧⌘B</code>), and Super Method (<code>Ctrl+U / ⌘U</code>) which navigates to a parent module.</p>

<p>There is also a handy ‘Go to Implementation’ gutter icon to help you quickly switch between traits, types, and impls:
</p>
<div class="pic"><img src="/assets/features/navigation/goto_impl_gutter.png" width="500"></div>
<p></p>

<p>If the <i>experimental macro expansion engine</i> is turned on in <strong>Settings / Preference | Languages & Frameworks | Rust | Expand declarative macros</strong>, all navigation actions are also available inside macro calls:</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=500
        src="/assets/features/navigation/navigation_in_macros.png" data-gif="/assets/features/navigation/navigation_in_macros.gif"/>
</div>
<p></p>
<p>To explore the structure of the currently opened file, press <code>Ctrl+F12 / ⌘F12</code>:</p>
<div class="pic"><img src="/assets/features/navigation/file_structure.png" width="400"></div>
<p></p>

  <h2 id="analysis" align="center">Code analysis</h2>
<h3>Inspections</h3>
<p>IntelliJ Rust uses a set of inspections to monitor code as you type. You can configure the list of inspections, and set their severities and scopes in <strong>Settings / Preference | Editor | Inspections</strong>.</p>
<p>
  By default, most inspections work on-the-fly and suggest quick-fixes to be applied right away. Below are a few examples.
</p>
<table border="1" cellpadding="5">
  <tr>
    <td width="33.3%">Type check errors:</td>
    <td width="33.3%">‘Not such field’ annotation:</td>
    <td>Accessing private items:</td>
  </tr>
  <tr>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/type_checks.png" data-gif="/assets/features/code_analysis/type_checks.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/nosuch_field.png" data-gif="/assets/features/code_analysis/nosuch_field.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/make_public.png" data-gif="/assets/features/code_analysis/make_public.gif"/></td>
  </tr>
</table>
<br/>
<p>You can also run inspections on demand by calling <strong>Code | Inspect Code</strong>. In this case, the results are shown in a separate window, from which you can apply quick fixes to a single case, or to several cases at a time:</p>
<div class="pic"><img src="/assets/features/code_analysis/inspections_batch.png" width="600"></div>
<p></p>


<h3 id="external-linters">External linters</h3>
<p>In addition to the built-in set of inspections, you can run Cargo Check or Clippy without leaving the IDE. Select the linter in <strong>Settings / Preference | Languages & Frameworks | Rust | Cargo</strong>, and run it from the Cargo tool window.
</p>
<p>
  You also have the option to run external linters on-the-fly along with other inspections, yet this may cause significant performance slowdown.
</p>





  <h2 id="cargo">Cargo support</h2>
<p>Intellij Rust fully supports Cargo-based Rust projects: it provides a Cargo template for new projects and takes project-level information from <code>Cargo.toml</code> files to open the existing ones.
</p>
<p>
  By the way, <code>.toml</code> files get code assistance too, since the IntelliJ <a href="https://plugins.jetbrains.com/plugin/8195-toml">TOML</a> plugin is installed in pair with IntelliJ Rust.</p>
<p>In the Cargo tool window, you can see all the workspace members and targets. From there, it’s easy to monitor the status of your project modules and refresh them when needed, run targets in a single click, call Cargo commands, reformat code using <a href="https://github.com/rust-lang/rustfmt">Rustfmt</a>, and run external linters/LINK TO PREV CHAPTER/.</p>
<p><strong>Run Anything</strong> is a very handy IDE feature, which includes Cargo commands: just press <code>Ctrl</code> twice and start typing the command you want to run:</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=500
                      src="/assets/features/cargo/cargo_run_anything.png" data-gif="/assets/features/cargo/cargo_run_anything.gif"/>
</div>
<p></p>

<p>Every call to a Cargo command is essentially an automatic creation of a Cargo Command run/debug configuration. You can create more configurations of this type in the <strong>Edit Configurations</strong> dialog, adjust the settings to your needs, and use these configurations with Run /ICON/ and Debug /ICON/ (CLion) actions.</p>
<div class="pic"><img src="/assets/features/cargo/rd_config.png" width="600"></div>
<p></p>


  <h2 id="testing">Testing</h2>
<p>When you run <code>cargo test</code> /OR USE OTHER OPTIONS/, IntelliJ Rust employs the IDE's built-in test runner to help you explore the results.
</p>
<p>The test runner window shows the status and duration of all tests, lets you quickly jump to the corresponding code, sort, and import/export the results: IMG
</p>
<p>THIS SHOULD BE THE 1ST PARAGRAPH, WAYS OF RUNNING TESTS You can also start a run or debug (in CLion) session for tests using gutter icons: IMG</p>


  <h2 id="debug">Debug and Dynamic Analysis (CLion)</h2>
<p>IntelliJ Rust integrates with both GDB and LLDB debuggers in CLion. All of the essential debug features like breakpoints, stepping actions, watches, and others, are fully available for your Rust code. As a plus, CLion debugger provides hexadecimal view for integer variables, and the options to step into disassembly and view raw memory.</p>

<p>The plugin’s bundled formatters for Rust types are loaded automatically. You can also switch to the compiler’s renderers, or turn the formatters off completely in the <strong>Debugger Data Views</strong> settings: IMG
</p>

<p>Bundled renderers not only give a tree-view visualization and provide elements access for strings, structs, enums, and vectors - they also support standard library types like <code>HashMap</code>, <code>HashSet</code>, <code>Rc</code>, <code>Arc</code>, <code>Cell</code>, and <code>Ref</code>. - IMG</p>
<p>
  During a debug session, you can explore threads and frames separately, and evaluate expressions (this functionality is limited to what is currently provided by the Rust expression parsers in GDB and LLDB).</p>
<p>The values of local variables are also shown inline in the editor, and if you enable hex view, CLion will add the formatted values into the inlined presentation as well.</p>
<p>To jump into memory, select a pointer variable, and call Show in Memory View: IMG </p>

<p>CLion’s debugger functionality stays fully available if you target a remote machine. With the executable running remotely under gdbserver, you can connect to it from CLion, and inspect the code as if it was running locally (learn more/LINK/).</p>

<p>To help you work on performance improvements, CLion integrates with CPU profiler on Linux (Perf) and macOS (DTrace). Run profiling /ICON/ on your Rust project /A DEBUG CONFIGURATION/, and get the results presented in a flame graph, call tree, and method list: - IMG
</p>

<p>See CLion web help for details on how to configure the profiler and interpret results.</p>

<p>One more option for dynamic analysis in running your program under Valgrind Memcheck /LINK to CLion help/, available on Linux and macOS. This memory error detector can help you deeper investigate the behavior of unsafe{} blocks and Rust wrappers around C.</p>

<h2 id="coverage">Code coverage</h2>
<p>Coverage analysis for your Rust code is implemented on top of the grcov/LINK/ utility, which you’ll be prompted to install. Note that currently, this feature is not available in CLion. In IDEA and other IDEs, all you need is to have the nightly toolchain available in order to instrument your code properly, and run the configuration using /ICON/: - IMG</p>




  <h2>Smart editor</h2>

  {% include feature-pic.html i="feature-editor" %}

  <div class="feature">
    <h3>Syntax highlighting</h3>

    <p>IntelliJ Rust, apart from basic lexer highlighting, also highlights resolved types, functions, variables (marking
      out mutable ones) and macros. All color schemes are customizable and we support both <i>Default</i> and
      <i>Darcula</i> themes out of the box.</p>
  </div>

  <div class="feature">
    <h3>Code formatter</h3>

    <p><b>Reformat Code</b> <kbd>Ctrl+Alt+L</kbd> reformats current file or selection using our custom, fully functional
      formatter based on IntelliJ's formatting engine. There's also a special action
      for formatting code with rustfmt.
  </div>

  <div class="feature">
    <h3>Code selection</h3>

    <p>To select a block of code place a cursor inside block and press <kbd>Ctrl+W</kbd> to expand it to an expression,
      to a line, to a logical block of code, and so on. To shrink selection press <kbd>Ctrl+Shift+W</kbd> as many
      times as needed.</p>
  </div>

  <div class="feature">
    <h3>Code commenting</h3>

    <p>After selecting a block, you can apply a block comment (<kbd>Ctrl+Shift+/</kbd>) or line comment
      (<kbd>Ctrl+/</kbd>) to it. The same shortcuts will remove existing comments from selected lines too.</p>
  </div>

  <div class="feature">
    <h3>Code folding</h3>

    <p>Code folding, auto-insertion of braces, brackets &amp; quotes, matching brace/bracket highlighting, etc.</p>
  </div>

  <div class="feature">
    <h3>On-the-fly analysis<abbr class="wip" title="Work In Progress">WIP</abbr></h3>

    <p>Errors are shown as you type. Among others, we catch syntax errors, missing fields/methods and unnecessary
      parens. We also support IntelliJ's built-in spell-checker.</p>
  </div>
</div>


<div class="feature-group">
  <h2>Code Completion<abbr class="wip" title="Work In Progress">WIP</abbr></h2>

  {% include feature-pic.html i="feature-completion" %}

  <div class="feature feature-major">
    <p>
      IntelliJ Rust features built from scratch code completion, leveraging IntelliJ Platform capabilities.
      <kbd>Ctrl+Space</kbd> invokes completion. We <a href="/docs/faq.html#racer">do not</a> plan
      to use <code>racer</code>. Most of the code completion is implemented, but support
      for macros is a work in progress.

    <p>Remember, if the smart completion does not work for your particular case, you can always invoke "dumb completion"
      via <kbd>Alt+/</kbd>. It merely suggests identifiers already present in the file, but works surprisingly well.</p>
  </div>
</div>


<div class="feature-group">
  <h2>Source code navigation</h2>

  {% include feature-pic.html i="feature-navigation" %}

  <p>There are a number of actions for efficient navigation across your project and dependencies.</p>

  <div class="feature">
    <h3>Find Usages<abbr class="wip" title="Work In Progress">WIP</abbr></h3>
    <p><kbd>Alt+F7</kbd> finds usages of element at caret.</p>
  </div>

  <div class="feature">
    <h3>Goto Declaration</h3>
    <p><kbd>Ctrl+B</kbd> goes to the definition of the symbol at caret.</p>
  </div>

  <div class="feature">
    <h3>Goto Class</h3>
    <p><kbd>Ctrl+N</kbd> search for a struct or enum by name.</p>
  </div>

  <div class="feature">
    <h3>Goto Symbol</h3>
    <p><kbd>Ctrl+Shift+Alt+N</kbd> searches for any symbol (types, methods, functions, fields) by name. Together with
      <kbd>Ctrl+N</kbd> it is the main method to explore large projects.</p>
  </div>

  <div class="feature">
    <h3>Goto Super</h3>
    <p><kbd>Ctrl+U</kbd> navigates to the parent module.</p>
  </div>

  <div class="feature">
    <h3>File Structure</h3>
    <p><kbd>Ctrl+F12</kbd>, <kbd>Alt+7</kbd> brings up an overview of the current file.</p>
  </div>

  <div class="feature side-pic">
    {% include feature-pic.html i="feature-nav-to-impl"%}
  </div>

  <div class="feature">
    <h3>Implementations</h3>
    <p>
      Gutter icon or <kbd>Ctrl+Alt+B</kbd> shortcut can be used to navigate between traits or types and impls.
    </p>
  </div>
</div>


<div class="feature-group">
  <h2>Code generation and refactorings</h2>

  <div class="feature feature-major">
    <h3>'Surround With' and Live Templates</h3>

    <p>There is a number of built in live templates and you can define your own. Different live templates are available
      in different contexts. Use <kbd>Ctrl+J</kbd> to list templates available in context.</p>

    <ul class="with-side-pic">
      <li>
        {% include feature-gfy.html n="UnrulyMajorElephantseal" %}
        <p><kbd>p</kbd>, <kbd>pd</kbd>, <kbd>ppd</kbd> - <code>println!</code> value with <code>{}</code>, debug
          <code>{:?}</code> and pretty debug <code>{:#?}</code> formats.</p>
      </li>

      <li>
        {% include feature-gfy.html n="PlushOddballBoilweevil" %}
        <p><kbd>a</kbd>, <kbd>ae</kbd> - <code>assert!</code> / <code>assert_eq!</code></p>
      </li>

      <li>
        {% include feature-gfy.html n="ShyThatAmericanquarterhorse" %}
        <div class="p">
          <p><kbd>tfn</kbd> - test function boilerplate</p>
          <p><kbd>tmod</kbd> - test module boilerplate</p>
        </div>
      </li>

      <li>
        {% include feature-gfy.html n="GlamorousUnacceptableHowlermonkey" %}
        <p><kbd>f</kbd>, <kbd>pf</kbd> - (<code>pub</code>) field name and type, applicable inside struct
          definitions.</p>
      </li>

      <li>
        {% include feature-gfy.html n="WelldocumentedUnsteadyCougar" %}
        <p><kbd>loop</kbd>, <kbd>while</kbd>, <kbd>for</kbd> templates. You can select a fragment of code and press
          <kbd>Ctrl+Alt+J</kbd> to invoke <b>Surround With Live Template</b> action.</p>
      </li>
    </ul>
  </div>

  <div class="feature feature-major">
    <h3>Refactorings<abbr class="wip" title="Work In Progress">WIP</abbr></h3>

    <div class="feature-group grid">
      <div class="feature">
        <p><b>Expand module</b>: invoke this refactoring inside <code>foo.rs</code> file to get
          <code>foo/mod.rs</code>. Also available as a quick fix for unresolved module declaration.</p>
      </div>

      <div class="feature">
        <p><b>Introduce variable</b>: use <kbd>Ctrl+Alt+V</kbd> or <code>.let</code> postfix template to extract a variable from an expression.</p>
      </div>
    </div>
  </div>

  <div class="feature feature-major">
    <h3>Intentions</h3>

    <p>Intentions and quick fixes are micro refactorings automatically available depending on the context. If some
      intentions are available, a light bulb icon appears in the editor. You can use <kbd>Alt+Enter</kbd> to invoke a
      quick fix.</p>

    <div class="feature-group grid">
      <div class="feature">
        {% include feature-gfy.html n="PessimisticFlashyAustraliancurlew" %}
        <p><b>Contract module</b>: the opposite of <i>Expand Module</i> refactoring. Available only if there are no
          child modules.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="HauntingAgonizingDuck" %}
        <p><b>Create module file</b>: if you have <code>mod foo;</code>, but no <code>foo.rs</code>
          this quick fix will create the missing file.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="BleakWholeGalapagospenguin" %}
        <p><b>Extract inline module</b>: move <code>mod foo { ... }</code> to a separate file.</p>
      </div>

      <div class="feature" id="add-derive">
        {% include feature-gfy.html n="ChubbyAcrobaticBrahmanbull" %}
        <p><b>Add derive clause</b>: adds <code>#[derive(..)]</code> attribute to structs and enums.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="CluelessGiddyBullfrog" %}
        <p><b>Remove/Add curly braces</b>: toggles between <code>use foo::{bar}</code> and
          <code>use foo::bar</code>.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="ImperfectFreeGecko" %}
        <p><b>Add missing fields</b>: a handy way to fill out the struct literal template.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="GlisteningCostlyAntarcticfurseal" %}
        <p><b>Implement methods</b>: quickly scafold an impl.</p>
      </div>
    </div>

  </div>
</div>


<div class="feature-group">
  <h2>Documentation</h2>
  {% include feature-pic.html i="feature-doc" %}

  <div class="feature half">
    <h3>Highlighting</h3>
    <p>IntelliJ Rust highlights important parts of documentation comments, so they never look so bland.</p>
  </div>

  <div class="feature half">
    <h3>Quick documentation</h3>
    <p><kbd>Ctrl+Q</kbd> shows docs for the symbol at caret.</p>
  </div>
</div>

<div class="feature-group">
  <h2>Reading code</h2>
  {% include feature-pic.html i="feature-reading" %}

  <div class="feature half">
    <h3>Quick documentation</h3>
    <p><kbd>Ctrl+Q</kbd> shows docs for the symbol at caret.</p>
  </div>

  <div class="feature half">
    <h3>Documentation highlighting</h3>
    <p>IntelliJ Rust highlights important parts of documentation comments, so they never look so bland.</p>
  </div>

  <div class="feature half">
    <h3>Parameter hints</h3>
    <p>In the editor, you can see hints with names of parameters and types of local variables</p>
  </div>

  <div class="feature half">
    <h3>Type information</h3>
    <p>Use <kbd>Ctrl+Shift+P</kbd> to view the type of selected expression.</p>
  </div>


</div>


<div class="feature-group side-pic-showcase">
  <h2>Running</h2>

  <div class="feature side-pic">
    {% include feature-pic.html i="feature-runconfig" %}
  </div>

  <div class="feature">
    <h3>Configurations</h3>

    <p>Built-in <code>Cargo Command</code> run configuration allows to build,
      test and run Rust code.
    </p>

  </div>


  <div class="feature side-pic">
    {% include feature-gfy.html n="FinePopularGreathornedowl" %}
  </div>

  <div class="feature">
    <h3>Context aware</h3>

    You can use <kbd>Ctrl+Shift+F10</kbd> shortcut to run a <code>main</code> or a <code>test</code> function.
    Alternatively, you can use the icon in the gutter area.
  </div>


  <div class="feature side-pic">
    {% include feature-gfy.html n="VelvetySerpentineCowbird" %}
  </div>

  <div class="feature">
    <h3>Synergy</h3>

    You can combine <kbd>Ctrl+Alt+Shift+N</kbd> with <kbd>Ctrl+Shift+F10</kbd> to
    find and execute a test without switching between code and tests.
  </div>
</div>
