---
layout: features
title: Features
permalink: /features/
class: features-page
---

<style>
  table {
    width: 100%; /* Ширина таблицы */
  }
  td {
    padding: 5px; /* Поля в ячейках */
    vertical-align: top; /* Выравнивание по верхнему краю ячеек */
  }
</style>

{% include doc-shortcut-tip.html %}


<h2 id="editor" align="center">Smart editor</h2>
<h3>Syntax highlighting</h3>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%">On top of the basic lexer highlighting, Intellij Rust highlights inferred types and macros, including generated modules and methods from <code>impl</code> blocks. It also marks mutable elements in your code:</td>
    <td>Those expressions and functions within <code>unsafe {}</code> blocks that perform unsafe operations are additionally highlighted with a contrast background:</td>
  </tr>
  <tr>
    <td><img src="/assets/features/smart_editor/highlight_basic.png" width="400"></td>
    <td><img src="/assets/features/smart_editor/highlight_unsafe.png" width="400"></td>
  </tr>
</table>
<p></p>
<p>The highlighting palette is fully customizable for both Darcula and Light color schemes.</p>



  <h3>Quick docs and Quick definition</h3>
<table border="1" cellpadding="5">
  <tr>
    <td width="50%" >At any code element, including library functions, invoke <strong>Quick Doc</strong> (<code>Ctrl+Q / F1</code>) to view the documentation popup. If there is a piece of code in the docs, it will be formatted and highlighted properly:</td>
    <td>To view the implementation or declaration of an element without leaving your current context, call <strong>Quick Definition</strong> by pressing <code>Ctrl+Shift+I / ⌥Space</code>:</td>
  </tr>
  <tr>
    <td><img src="/assets/features/smart_editor/quick_doc.png" width="400"></td>
    <td><img src="/assets/features/smart_editor/quick_def.png" width="400"></td>
  </tr>
</table>
<p></p>
<p>Another handy option for viewing documentation is the <img src="/assets/features/smart_editor/docsrs.svg" width="16"> gutter icon, which you can see next to the extern crate declarations. Click it, and you will jump right to the particular crate’s description on <a href="docs.rs">docs.rs</a>.</p>

<!--div class="feature-group">
  <div class="feature half">
<p>At any code element, including library functions, invoke Quick Doc (Ctrl+Q / F1) to view the documentation popup. If there is a piece of code in the docs, it will be formatted and highlighted properly:</p>
    <p>img 3</p>
  </div>
  <div class="feature half">
<p>To view the implementation or declaration of an element without leaving your current context, call Quick Definition by pressing Ctrl+Shift+I / ⌥Space:</p>
    <p>img 4</p>
  </div>
  <p>Another handy option for viewing documentation is the <img src="/assets/features/smart_editor/docsrs.svg" width="16"> gutter icon, which you can see next to extern crate declarations. Click it, and you will jump right to the particular crate’s description on docs.rs.</p>
</div-->


  <h3>Hints and Type information</h3>
<p>Hints for function argument names, types, and lambda parameters are displayed in the editor, and IntelliJ Rust adjusts them as you type. If you prefer not to see some of the hints or hide them entirely, you can always tune that in the settings.</p>


<table border="1" cellpadding="5">
  <tr>
    <td width="50%" >If you press <code>Ctrl</code> and hover the mouse over a hint, it will turn into an interactive inlay:</td>
    <td>You can also get the type information by calling <strong>Type Info</strong> (<code>Ctrl + Shift + P / ⌃⇧P</code>) for a selected expression:</td>
  </tr>
  <tr>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=500
               src="/assets/features/smart_editor/hints_inlay.png" data-gif="/assets/features/smart_editor/hints_inlay.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=500
             src="/assets/features/smart_editor/type_info.png" data-gif="/assets/features/smart_editor/type_info.gif"/></td>
  </tr>
</table>

<!--
<p>If you press <code>Ctrl</code> and hover the mouse over a hint, it will get into an interactive inlay:
<img class="gif" data-wait="true" data-scope="gif-scope" width=500
     src="/assets/features/smart_editor/hints_change.png" data-gif="/assets/features/smart_editor/hints_change.gif"/>
</p>

<p>You can also get the type information by calling Type Info (<code>Ctrl + Shift + P / ?</code>) for a selected expression:
<img class="gif" data-wait="true" data-scope="gif-scope" width=500
     src="/assets/features/smart_editor/type_info.png" data-gif="/assets/features/smart_editor/type_info.gif"/>
</p>
-->
<p></p>
<p>Another alternative to view the types is to turn off the <strong>Show local variable type hints</strong> option and hover the mouse over a variable while holding <code>Ctrl / ⌘</code>.</p>



  <h3>Macro expansion popup</h3>
<p>To explore the expansion of any declarative macro in your code, press <code>Alt/⌥ + Enter</code> and choose to view either one-step or full recursive expansion. This feature is a part of the macro expansion functionality that affects most of the code insight.
</p>
<div class="pic">
<img class="gif" data-wait="true" data-scope="gif-scope" width=550
     src="/assets/features/smart_editor/macro_expansion.png" data-gif="/assets/features/smart_editor/macro_expansion.gif"/>
</div>
<p></p>

  <h3>Doc comments highlighting</h3>
<p>Code blocks inside doc comments are treated as valid Rust code: you get full code insight including syntax highlighting, <a href="#completion">completion</a>, and <a href="#intentions">intentions</a>.</p>
<div class="pic">
  <img src="/assets/features/smart_editor/doc_comments_hl.png" width="550">
</div>
<p></p>

  <h3>Code style and formatting</h3>

<p>IntelliJ Rust helps your code stay compliant with style guidelines and naming conventions. You can configure the details of the preferred style in <strong>Settings / Preferences | Editor | Code style | Rust</strong>, and adjust the <a href="#inspections">inspections</a> that validate your code against Rust naming conventions.</p>

<p>To explicitly reformat your code, you can use the built-in action (<code>Code | Reformat</code> or <code>Ctrl+Alt+L / ⌥⌘L</code>), or call <a href="https://github.com/rust-lang/rustfmt">rustfmt</a> (<code>Code | Reformat Cargo Project with Rustfmt</code> or using the button in the Cargo tool window).</p>



  <h2 id="completion" align="center">Code completion</h2>
<table border="1" cellpadding="5">
  <tr>
    <td>Completion for your Rust code works as you type. It is available for attributes and elements inside <code>#[derive]</code>, including standard library traits:</td>
    <td>For out-of-scope items, like the cases of adding a trait import during method completion, the corresponding <code>use</code> item is inserted automatically:</td>
  </tr>
  <tr>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_completion/completion_derive.png" data-gif="/assets/features/code_completion/completion_derive.gif"/></td>
    <td><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_completion/completion_trait.png" data-gif="/assets/features/code_completion/completion_trait.gif"/></td>
  </tr>
</table>
<p></p>
<p>In addition, IntelliJ Rust provides completion inside macro calls. It knows the resulting macro substitution and suggests the applicable items:</p>

<div class="pic"><img src="/assets/features/code_completion/completion_macro_calls.png" width="400">
</div>
<p></p>


  <h2 id="codegen" align="center">Code generation</h2>

    <h3 id="intentions">Intentions and quick-fixes</h3>
<table border="1" cellpadding="5">
  <tr>
    <td>The <i>Add missing fields</i> quick fix helps you interactively define field values of struct literals:</td>
    <td>You can quickly add <code>#[derive]</code> clauses and <code>impl</code> blocks for structs and enums, and perform struct-to-tuple and tuple-to-struct conversion:</td>
  </tr>
  <tr>
    <td>
      <img class="gif" data-wait="true" data-scope="gif-scope" width="400"
           src="/assets/features/code_generation/missing_fields.png" data-gif="/assets/features/code_generation/missing_fields.gif"/>
    </td>
    <td><img src="/assets/features/code_generation/add_derive_close.png" width="250"></td>
  </tr>
</table>
<p></p>
<p>Auto-import works for all unresolved references in your code:</p>
<div class="pic">
  <img class="gif" data-wait="true" data-scope="gif-scope" width=500
       src="/assets/features/code_generation/auto-import.png" data-gif="/assets/features/code_generation/auto-import.gif"/>
</div>
<p></p>
<p>IntelliJ Rust also checks <code>match</code> expressions in your code and suggests removing unreachable patterns or adding the missing ones, including the cases of complex patterns with multiple types. This inspection also supports <a href="https://github.com/rust-lang/rfcs/blob/master/text/2005-match-ergonomics.md">match ergonomics</a>.</p>
<div class="pic">
  <img src="/assets/features/code_generation/mathc_checks.png" width="400">
</div>
<p></p>

    <h3>Live templates, ‘Surround with’, and Postfix completion</h3>
<p>There is a number of ready-to-use live templates to help you insert frequently used Rust constructs into your code. You can always customize and extend this set in <strong>Settings / Preferences | Editor | Live Templates</strong>.
</p>
<p>
  Press <code>Ctrl/⌘ + J</code> to view the templates available in the current context. If you already know the abbreviation, just start typing it, choose from the list of suggestions, and then press <code>Tab</code> to navigate between the template variables:
</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=500
        src="/assets/features/code_generation/livetemplates_basic.png" data-gif="/assets/features/code_generation/livetemplates_basic.gif"/>
</div>
<p></p>

<p>You can select a piece of code and press <code>Ctrl+Alt+J / ⌥⌘J</code> to surround it with a live template, or press <code>Ctrl+Alt+T / ⌥⌘T</code> to surround it with <code>loop</code>, <code>while</code>, <code>if</code>, <code>for</code>, and other wrappers, depending on the context.</p>
<p>Another option to insert code constructs is postfix completion. For example, type <code>.dbg</code> after an expression to insert a <code>dbg!</code> invocation for it:</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=600
        src="/assets/features/code_generation/postfix.png" data-gif="/assets/features/code_generation/postfix.gif"/>
</div>
<p></p>


    <h3>Refactorings</h3>
<p>IntelliJ Rust supports the following refactorings:</p>
<ul>
  <li>Rename            (Shift+F6 / ⇧F6)</li>
  <li>Extract Variable  (Ctrl+Alt+V / ⌥⌘V)</li>
  <li>Extract Parameter (Ctrl+Alt+P / ⌥⌘P)</li>
  <li>Extract Method    (Ctrl+Alt+M / ⌥⌘M)</li>
  <li>Convert to Tuple / Struct</li>
  <li>Promote / Downgrade module</li>
</ul>

<p>One of the most frequently used ones, <strong>Rename</strong> (<code>Shift+F6 / ⇧F6</code>), changes the name of a symbols and automatically corrects all the references in the code. For example, when you rename a trait item, the corresponding items in the trait implementations are renamed as well:</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=400
        src="/assets/features/code_generation/rename_trait.png" data-gif="/assets/features/code_generation/rename_trait.gif"/>
</div>
<p></p>
<p>You can rename symbols in-place or use a dialog with a preview.</p>
<p>At any place in your code, call <strong>Rector This</strong> (<code>Ctrl+Shift+Alt+T / ⌃T</code>) to view the list of all context-depend refactorings. As an example, here is how you can easily put the result of an expression into a variable, affecting all usages:
</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=600
        src="/assets/features/code_generation/extract_var.png" data-gif="/assets/features/code_generation/extract_var.gif"/>
</div>
<p></p>


  <h2 id="navigation" align="center">Navigation and search</h2>
<h3>Search everywhere</h3>
<p>The easiest way to find anything in the IDE - a code item, action, or UI element - is <strong>Search Everywhere</strong>. Press <code>Shift/⇧</code> twice and start typing what you’re looking for. Completion also works in this dialog to help you find the desired item, and you can narrow the search down by setting the required scope:</p>
<div class="pic"><img src="/assets/features/navigation/search_everywhere.png" width="650"></div>
<p></p>

<h3>Find Usages</h3>
<p>To locate all the occurrences of any symbol in your code, place the caret on it and call <strong>Find Usages</strong>. The IDE understands symbol context, so you will not see textual matches in the results.</p>
<p>You can highlight the usages in the current file by pressing <code>Ctrl+Shift+F7 / ⇧⌘F7</code>, and then jump between them, or list all usages in a separate window using <code>Alt+F7 / ⌥F7</code>. You can filter and group the results, and jump back to the source code:
</p>
<div class="pic"><img src="/assets/features/navigation/find_usages.png" width="500"></div>
<p></p>


<h3>Go-To and File Structure</h3>
<p>In addition to <strong>Search Everywhere</strong>, you can separately call <strong>Go To</strong> class (<code>Ctrl+O / ⌘O</code>), symbol (<code>Ctrl+Alt+O / ⌥⌘O</code>), or file (<code>Ctrl+Shift+O / ⇧⌘O</code>).</p>

<p>To navigate through declarations/definitions and hierarchies in your code, use Go-To action for Declaration (<code>Ctrl+B / ⌘B</code>), Definition (<code>Ctrl+Alt+B / ⌥⌘B</code>), Type Declaration (<code>Ctrl+Shift+B / ⇧⌘B</code>), and Super Method (<code>Ctrl+U / ⌘U</code>), which navigates to a parent module.</p>

<p>There is also a handy <i>Go to Implementation</i> gutter icon to help you quickly switch between traits, types, and impls:
</p>
<div class="pic"><img src="/assets/features/navigation/goto_impl_gutter.png" width="500"></div>
<p></p>

<p>All navigation actions are available inside macro calls when the <i>experimental macro expansion engine</i> is turned on (<strong>Settings / Preferences | Languages & Frameworks | Rust | Expand declarative macros</strong>):</p>
<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=500
        src="/assets/features/navigation/navigation_in_macros.png" data-gif="/assets/features/navigation/navigation_in_macros.gif"/>
</div>
<p></p>

<p>You can also explore the structure of the currently opened file in the <strong>Structure</strong> view (<code>Ctrl+F12 / ⌘F12</code>):</p>
<div class="pic"><img src="/assets/features/navigation/file_structure.png" width="400"></div>
<p></p>

  <h2 id="analysis" align="center">Code analysis</h2>
<h3 id="inspections">Inspections</h3>
<p>IntelliJ Rust uses a set of inspections to monitor code as you type. You can configure the list of them, and set the severities and scopes in <strong>Settings / Preference | Editor | Inspections</strong>.</p>
<p>
  By default, most inspections work on-the-fly and suggest quick-fixes to be applied right away. Find a few examples below:
</p>
<table border="1" cellpadding="5">
  <tr>
    <td>Type check errors:</td>
    <td><i>Not such field</i> annotation:</td>
    <td>Accessing private items:</td>
  </tr>
  <tr>
    <td height="200"><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/type_cast.png" data-gif="/assets/features/code_analysis/type_cast.gif"/></td>
    <td height="200"><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/nosuch_field.png" data-gif="/assets/features/code_analysis/nosuch_field.gif"/></td>
    <td height="200"><img class="gif" data-wait="true" data-scope="gif-scope" width=400
             src="/assets/features/code_analysis/make_public.png" data-gif="/assets/features/code_analysis/make_public.gif"/></td>
  </tr>
</table>
<p></p>
<p>You can also run the inspections on demand by calling <strong>Code | Inspect Code</strong>. The results will be shown in a separate window, from which you can apply quick-fixes to a single case or to several cases at a time:</p>
<div class="pic"><img src="/assets/features/code_analysis/inspections_batch.png" width="650"></div>
<p></p>


<h3 id="external-linters">External linters</h3>
<p>In addition to the built-in set of inspections, you can run <strong>Cargo Check</strong> or <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> without leaving the IDE. Select the linter in <strong>Settings / Preference | Languages & Frameworks | Rust | Cargo</strong>, and run it from the Cargo tool window.
</p>
<!--p>
  There is also the option to run external linters on-the-fly along with other inspections, yet this may cause significant performance slowdown.
</p-->





  <h2 id="cargo">Cargo support</h2>

<p>The plugin fully supports Cargo-based Rust applications: it provides a template for new projects and takes project-level information from <code>Cargo.toml</code> files to open the existing ones.</p>

<p>The <a href="https://plugins.jetbrains.com/plugin/8195-toml">IntelliJ TOML</a> plugin installs in pair with IntelliJ Rust, so code assistance is available for <code>.toml</code> files as well.</p>

<p>Cargo tool window, shows all the workspace members and targets. From there, you can monitor the status of your project modules and refresh them when needed, run targets in a single click, call Cargo commands, reformat code using <a href="https://github.com/rust-lang/rustfmt">Rustfmt</a>, and run <a href="#external-linters">external linters</a>.</p>

<p>The <strong>Run Anything</strong> popup includes Cargo commands: press <code>Ctrl</code> twice and start typing the command that you want to run.</p>

<div class="pic"><img class="gif" data-wait="true" data-scope="gif-scope" width=550
                      src="/assets/features/cargo/cargo_run_anything.png" data-gif="/assets/features/cargo/cargo_run_anything.gif"/></div>
<p></p>

<p>For every Cargo command you call, the IDE creates a temporary run/debug configuration. You can edit them and make new configurations out of the Cargo Command template in the <strong>Edit Configurations</strong> dialog. Then, you can use Run <img src="/assets/features/icons/icons_run.png" width="16"/> or Debug <img src="/assets/features/icons/icons_debug.png" width="16"/> (CLion) actions for them.</p>

<div class="pic"><img src="/assets/features/cargo/rd_config.png" width="600"></div>
<p></p>


  <h2 id="testing">Testing</h2>
<p>The quickest way to start a run or debug (in CLion) session for tests is by using the gutter icon menu:</p>
<div class="pic"><img src="/assets/features/testing/test_gutter.png" width="450"></div>
<p></p>

<p>When you run tests using gutter icons or by calling <code>cargo test</code>, IntelliJ Rust employs the IDE's built-in test runner to help you explore the results.</p>
<p>The test runner window shows the status and duration for each test, and lets you sort the results and jump to the corresponding code:</p>
<div class="pic"><img src="/assets/features/testing/test_runner.png" width="450"></div>
<p></p>



  <h2 id="debug">Debug and Dynamic Analysis (CLion)</h2>
<p>IntelliJ Rust integrates with both GDB and LLDB debuggers in CLion. All of the essential debug features like breakpoints, stepping, watches, and others, are fully available for your Rust code. As a plus, CLion can show hexadecimal view for integer variables, and lets you step into disassembly and view raw memory.</p>

<p>The plugin’s bundled Rust type formatters are loaded automatically. You can also switch to the compiler’s renderers, or turn the formatters off in the <strong>Debugger Data Views</strong> settings:</p>
<div class="pic"><img src="/assets/features/debugger/renderers.png" width="450"></div>
<p></p>

<p>Bundled renderers build tree-view visualization for strings, structs, enums, and vectors, helping you easily access chind elements. They also support standard library types like <code>HashMap</code>, <code>HashSet</code>, <code>Rc</code>, <code>Arc</code>, <code>Cell</code>, and <code>Ref</code>.</p>
<div class="pic"><img src="/assets/features/debugger/type_rendering.png" width="450"></div>
<p></p>

<p>
  During a debug session, you can explore threads and frames separately, and evaluate expressions (this functionality is limited to what is currently provided by the Rust expression parsers in GDB and LLDB).</p>
<p>The values of local variables are also shown inline in the editor, and if you <a href="https://www.jetbrains.com/help/clion/using-hexadecimal-view.html">enable hex view</a>, CLion will add the formatted values into the inlined presentation as well.</p>

<p>To jump into memory, select a pointer variable, and call <strong>Show in Memory View</strong>.</p>
<div class="pic"><img src="/assets/features/debugger/debugger_overview.png" width="700"></div>
<p></p>

<p>CLion’s debugger functionality stays fully available even when you target a remote machine. With the executable running remotely under <i>gdbserver</i>, you can connect to it from CLion, and inspect your code as if the program was running locally (<a href="https://www.jetbrains.com/help/clion/remote-debug.html">learn more</a>).</p>

<p>To help you work on performance improvements, CLion integrates with CPU profiler on Linux (Perf) and macOS (DTrace). Run profiling <img src="/assets/features/icons/icons._profiler.png" width="16"/> for your Cargo Command configuration, and the results will be presented in a flame graph, call tree, and method list:
</p>
<div class="pic"><img src="/assets/features/debugger/profiler.png" width="600"></div>
<p></p>

<p>Refer to <a href="https://www.jetbrains.com/help/clion/cpu-profiler.html">CLion web help</a> for details on how to configure the profiler and interpret results.</p>

<p>One more option for dynamic analysis is <a href="https://www.jetbrains.com/help/clion/memory-profiling-with-valgrind.html">Valgrind Memcheck</a> available on Linux and macOS. This memory error detector can help you deeper investigate the behavior of <code>unsafe{}</code> blocks and Rust wrappers around C.</p>

<h2 id="coverage">Code coverage</h2>
<p>Coverage analysis for your Rust code is implemented on top of the <a href="https://github.com/mozilla/grcov">grcov</a> utility (you will be prompted to install it).<p>
</p>Note that currently, this feature is not available in CLion. In IDEA and other IDEs, all you need is to have the nightly toolchain available in order to instrument your code properly, and run the configuration using <img src="/assets/features/icons/icons._coverage.png" width="16"/>:</p>
<div class="pic"><img src="/assets/features/coverage/coverage.png" width="700"></div>
<p></p>


<!--

  <h2>Smart editor</h2>

  {% include feature-pic.html i="feature-editor" %}

  <div class="feature">
    <h3>Syntax highlighting</h3>

    <p>IntelliJ Rust, apart from basic lexer highlighting, also highlights resolved types, functions, variables (marking
      out mutable ones) and macros. All color schemes are customizable and we support both <i>Default</i> and
      <i>Darcula</i> themes out of the box.</p>
  </div>

  <div class="feature">
    <h3>Code formatter</h3>

    <p><b>Reformat Code</b> <kbd>Ctrl+Alt+L</kbd> reformats current file or selection using our custom, fully functional
      formatter based on IntelliJ's formatting engine. There's also a special action
      for formatting code with rustfmt.
  </div>

  <div class="feature">
    <h3>Code selection</h3>

    <p>To select a block of code place a cursor inside block and press <kbd>Ctrl+W</kbd> to expand it to an expression,
      to a line, to a logical block of code, and so on. To shrink selection press <kbd>Ctrl+Shift+W</kbd> as many
      times as needed.</p>
  </div>

  <div class="feature">
    <h3>Code commenting</h3>

    <p>After selecting a block, you can apply a block comment (<kbd>Ctrl+Shift+/</kbd>) or line comment
      (<kbd>Ctrl+/</kbd>) to it. The same shortcuts will remove existing comments from selected lines too.</p>
  </div>

  <div class="feature">
    <h3>Code folding</h3>

    <p>Code folding, auto-insertion of braces, brackets &amp; quotes, matching brace/bracket highlighting, etc.</p>
  </div>

  <div class="feature">
    <h3>On-the-fly analysis<abbr class="wip" title="Work In Progress">WIP</abbr></h3>

    <p>Errors are shown as you type. Among others, we catch syntax errors, missing fields/methods and unnecessary
      parens. We also support IntelliJ's built-in spell-checker.</p>
  </div>
</div>


<div class="feature-group">
  <h2>Code Completion<abbr class="wip" title="Work In Progress">WIP</abbr></h2>

  {% include feature-pic.html i="feature-completion" %}

  <div class="feature feature-major">
    <p>
      IntelliJ Rust features built from scratch code completion, leveraging IntelliJ Platform capabilities.
      <kbd>Ctrl+Space</kbd> invokes completion. We <a href="/docs/faq.html#racer">do not</a> plan
      to use <code>racer</code>. Most of the code completion is implemented, but support
      for macros is a work in progress.

    <p>Remember, if the smart completion does not work for your particular case, you can always invoke "dumb completion"
      via <kbd>Alt+/</kbd>. It merely suggests identifiers already present in the file, but works surprisingly well.</p>
  </div>
</div>


<div class="feature-group">
  <h2>Source code navigation</h2>

  {% include feature-pic.html i="feature-navigation" %}

  <p>There are a number of actions for efficient navigation across your project and dependencies.</p>

  <div class="feature">
    <h3>Find Usages<abbr class="wip" title="Work In Progress">WIP</abbr></h3>
    <p><kbd>Alt+F7</kbd> finds usages of element at caret.</p>
  </div>

  <div class="feature">
    <h3>Goto Declaration</h3>
    <p><kbd>Ctrl+B</kbd> goes to the definition of the symbol at caret.</p>
  </div>

  <div class="feature">
    <h3>Goto Class</h3>
    <p><kbd>Ctrl+N</kbd> search for a struct or enum by name.</p>
  </div>

  <div class="feature">
    <h3>Goto Symbol</h3>
    <p><kbd>Ctrl+Shift+Alt+N</kbd> searches for any symbol (types, methods, functions, fields) by name. Together with
      <kbd>Ctrl+N</kbd> it is the main method to explore large projects.</p>
  </div>

  <div class="feature">
    <h3>Goto Super</h3>
    <p><kbd>Ctrl+U</kbd> navigates to the parent module.</p>
  </div>

  <div class="feature">
    <h3>File Structure</h3>
    <p><kbd>Ctrl+F12</kbd>, <kbd>Alt+7</kbd> brings up an overview of the current file.</p>
  </div>

  <div class="feature side-pic">
    {% include feature-pic.html i="feature-nav-to-impl"%}
  </div>

  <div class="feature">
    <h3>Implementations</h3>
    <p>
      Gutter icon or <kbd>Ctrl+Alt+B</kbd> shortcut can be used to navigate between traits or types and impls.
    </p>
  </div>
</div>


<div class="feature-group">
  <h2>Code generation and refactorings</h2>

  <div class="feature feature-major">
    <h3>'Surround With' and Live Templates</h3>

    <p>There is a number of built in live templates and you can define your own. Different live templates are available
      in different contexts. Use <kbd>Ctrl+J</kbd> to list templates available in context.</p>

    <ul class="with-side-pic">
      <li>
        {% include feature-gfy.html n="UnrulyMajorElephantseal" %}
        <p><kbd>p</kbd>, <kbd>pd</kbd>, <kbd>ppd</kbd> - <code>println!</code> value with <code>{}</code>, debug
          <code>{:?}</code> and pretty debug <code>{:#?}</code> formats.</p>
      </li>

      <li>
        {% include feature-gfy.html n="PlushOddballBoilweevil" %}
        <p><kbd>a</kbd>, <kbd>ae</kbd> - <code>assert!</code> / <code>assert_eq!</code></p>
      </li>

      <li>
        {% include feature-gfy.html n="ShyThatAmericanquarterhorse" %}
        <div class="p">
          <p><kbd>tfn</kbd> - test function boilerplate</p>
          <p><kbd>tmod</kbd> - test module boilerplate</p>
        </div>
      </li>

      <li>
        {% include feature-gfy.html n="GlamorousUnacceptableHowlermonkey" %}
        <p><kbd>f</kbd>, <kbd>pf</kbd> - (<code>pub</code>) field name and type, applicable inside struct
          definitions.</p>
      </li>

      <li>
        {% include feature-gfy.html n="WelldocumentedUnsteadyCougar" %}
        <p><kbd>loop</kbd>, <kbd>while</kbd>, <kbd>for</kbd> templates. You can select a fragment of code and press
          <kbd>Ctrl+Alt+J</kbd> to invoke <b>Surround With Live Template</b> action.</p>
      </li>
    </ul>
  </div>

  <div class="feature feature-major">
    <h3>Refactorings<abbr class="wip" title="Work In Progress">WIP</abbr></h3>

    <div class="feature-group grid">
      <div class="feature">
        <p><b>Expand module</b>: invoke this refactoring inside <code>foo.rs</code> file to get
          <code>foo/mod.rs</code>. Also available as a quick fix for unresolved module declaration.</p>
      </div>

      <div class="feature">
        <p><b>Introduce variable</b>: use <kbd>Ctrl+Alt+V</kbd> or <code>.let</code> postfix template to extract a variable from an expression.</p>
      </div>
    </div>
  </div>

  <div class="feature feature-major">
    <h3>Intentions</h3>

    <p>Intentions and quick fixes are micro refactorings automatically available depending on the context. If some
      intentions are available, a light bulb icon appears in the editor. You can use <kbd>Alt+Enter</kbd> to invoke a
      quick fix.</p>

    <div class="feature-group grid">
      <div class="feature">
        {% include feature-gfy.html n="PessimisticFlashyAustraliancurlew" %}
        <p><b>Contract module</b>: the opposite of <i>Expand Module</i> refactoring. Available only if there are no
          child modules.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="HauntingAgonizingDuck" %}
        <p><b>Create module file</b>: if you have <code>mod foo;</code>, but no <code>foo.rs</code>
          this quick fix will create the missing file.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="BleakWholeGalapagospenguin" %}
        <p><b>Extract inline module</b>: move <code>mod foo { ... }</code> to a separate file.</p>
      </div>

      <div class="feature" id="add-derive">
        {% include feature-gfy.html n="ChubbyAcrobaticBrahmanbull" %}
        <p><b>Add derive clause</b>: adds <code>#[derive(..)]</code> attribute to structs and enums.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="CluelessGiddyBullfrog" %}
        <p><b>Remove/Add curly braces</b>: toggles between <code>use foo::{bar}</code> and
          <code>use foo::bar</code>.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="ImperfectFreeGecko" %}
        <p><b>Add missing fields</b>: a handy way to fill out the struct literal template.</p>
      </div>

      <div class="feature">
        {% include feature-gfy.html n="GlisteningCostlyAntarcticfurseal" %}
        <p><b>Implement methods</b>: quickly scafold an impl.</p>
      </div>
    </div>

  </div>
</div>


<div class="feature-group">
  <h2>Documentation</h2>
  {% include feature-pic.html i="feature-doc" %}

  <div class="feature half">
    <h3>Highlighting</h3>
    <p>IntelliJ Rust highlights important parts of documentation comments, so they never look so bland.</p>
  </div>

  <div class="feature half">
    <h3>Quick documentation</h3>
    <p><kbd>Ctrl+Q</kbd> shows docs for the symbol at caret.</p>
  </div>
</div>

<div class="feature-group">
  <h2>Reading code</h2>
  {% include feature-pic.html i="feature-reading" %}

  <div class="feature half">
    <h3>Quick documentation</h3>
    <p><kbd>Ctrl+Q</kbd> shows docs for the symbol at caret.</p>
  </div>

  <div class="feature half">
    <h3>Documentation highlighting</h3>
    <p>IntelliJ Rust highlights important parts of documentation comments, so they never look so bland.</p>
  </div>

  <div class="feature half">
    <h3>Parameter hints</h3>
    <p>In the editor, you can see hints with names of parameters and types of local variables</p>
  </div>

  <div class="feature half">
    <h3>Type information</h3>
    <p>Use <kbd>Ctrl+Shift+P</kbd> to view the type of selected expression.</p>
  </div>


</div>


<div class="feature-group side-pic-showcase">
  <h2>Running</h2>

  <div class="feature side-pic">
    {% include feature-pic.html i="feature-runconfig" %}
  </div>

  <div class="feature">
    <h3>Configurations</h3>

    <p>Built-in <code>Cargo Command</code> run configuration allows to build,
      test and run Rust code.
    </p>

  </div>


  <div class="feature side-pic">
    {% include feature-gfy.html n="FinePopularGreathornedowl" %}
  </div>

  <div class="feature">
    <h3>Context aware</h3>

    You can use <kbd>Ctrl+Shift+F10</kbd> shortcut to run a <code>main</code> or a <code>test</code> function.
    Alternatively, you can use the icon in the gutter area.
  </div>


  <div class="feature side-pic">
    {% include feature-gfy.html n="VelvetySerpentineCowbird" %}
  </div>

  <div class="feature">
    <h3>Synergy</h3>

    You can combine <kbd>Ctrl+Alt+Shift+N</kbd> with <kbd>Ctrl+Shift+F10</kbd> to
    find and execute a test without switching between code and tests.
  </div>
</div>
-->
